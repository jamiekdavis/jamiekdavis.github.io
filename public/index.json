
[{"content":"","date":"12 February 2026","externalUrl":null,"permalink":"/","section":"","summary":"","title":"","type":"page"},{"content":"","date":"12 February 2026","externalUrl":null,"permalink":"/categories/","section":"Categories","summary":"","title":"Categories","type":"categories"},{"content":"","date":"12 February 2026","externalUrl":null,"permalink":"/tags/data-engineering/","section":"Tags","summary":"","title":"Data Engineering","type":"tags"},{"content":"","date":"12 February 2026","externalUrl":null,"permalink":"/categories/explainer/","section":"Categories","summary":"","title":"Explainer","type":"categories"},{"content":"Polars is an open-source library built for working with tabular data that, over the last few years, has quickly caught up to pandas in terms of popularity. A huge advantage of polars over pandas is its ability to process data more efficiently. In this post, we’ll cover one of the key mechanisms that enables polars to do this: lazy mode!\nWhat is lazy mode? # Polars provides two ways to work with data:\neager - immediately executing a query line-by-line; lazy - identifying which corners can be cut and then executing the query. How lazy mode creates a dataframe? # Imagine that we want to load the names of the director in lowercase from movies with IMDB_Rating greater than 8.0. the following example from the imdb dataset.\nIn eager mode, our query would look like:\neager_query = ( pl.read_csv(f\u0026#34;./data/imdb.csv\u0026#34;) .select(pl.col(\u0026#34;IMDB_Rating\u0026#34;), pl.col(\u0026#34;Director\u0026#34;).str.to_lowercase()) .filter(pl.col(\u0026#34;IMDB_Rating\u0026#34;) \u0026gt; 8.0) ) And be executed as followed:\nOpen the imdb.csv file read in all 16 columns for all rows transform the Director column to lowercase apply a filter on the imdb_score column In lazy mode , our query would look like:\nlazy_query = ( pl.scan_csv(f\u0026#34;./data/imdb.csv\u0026#34;) .select(pl.col(\u0026#34;IMDB_Rating\u0026#34;), pl.col(\u0026#34;Director\u0026#34;).str.to_lowercase()) .filter(pl.col(\u0026#34;IMDB_Rating\u0026#34;) \u0026gt; 8.0) .collect() ) And be executed as followed:\nOpen theimdb.csv file apply the filter on the IMDB_Rating column while the CSV is being read in read 2 columns for only the filter rows transform the Director column to lowercase Notice how we have to include the .collect() method at the end of this query. This is because, unlike .read_csv() , the .scan_csv() method outputs a LazyFrame object, a representation of our query, which we then have to execute via the .collect() method to get a DataFrame.\nWe can visualise the optimised query plan as follows:\nlazy_query.explain(optimized=True) Which gives the following output:\nWITH_COLUMNS: [col(\u0026#34;Director\u0026#34;).str.lowercase()] CSV SCAN data/imdb.csv PROJECT 2/16 COLUMNS SELECTION: [(col(\u0026#34;IMDB_Rating\u0026#34;)) \u0026gt; (8.0)] How does polars optimize a query? # We do not have to specify how to optimize the query, when we use the lazy API, Polars automatically run several optimisations on our query. For example, in our above query polars noticed that it can limit the number of rows of data it needs load into a DataFrame and store in the memory by applying the filter clause as it is reading in the CSV file (this is called Predicate Pushdown).\nWhat\u0026rsquo;s the point of eager mode, then? # If lazy mode is so great, then why should I ever bother using eager mode? Eager mode is best for when we want full insight into how the query is being executed. So, we would likley want to make use of eager mode during development for debugging. Lazy mode really shines as we start working with bigger datasets, so we would likely want to use a lazy query when we move into production and are want to optimise a script for speed.\nClosing Remarks # Pandas has long been the go-to python library for tabular data, it integrates well with other packages, it has a huge community around it and is embedded in many products, so it is unlikely to be completely replaced anytime soon. However, as we have seen here, polars’ lazy mode gives it a competitive edge over pandas for ETL and production, and would be well-worth exploring on your next data-driven project.\n","date":"12 February 2026","externalUrl":null,"permalink":"/posts/polars-lazy/","section":"Posts","summary":"A brief introduction Polars lazy mode","title":"It Pays to Be Lazy","type":"posts"},{"content":"","date":"12 February 2026","externalUrl":null,"permalink":"/tags/polars/","section":"Tags","summary":"","title":"Polars","type":"tags"},{"content":"","date":"12 February 2026","externalUrl":null,"permalink":"/posts/","section":"Posts","summary":"","title":"Posts","type":"posts"},{"content":"","date":"12 February 2026","externalUrl":null,"permalink":"/tags/python/","section":"Tags","summary":"","title":"Python","type":"tags"},{"content":"","date":"12 February 2026","externalUrl":null,"permalink":"/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"},{"content":"","externalUrl":null,"permalink":"/authors/","section":"Authors","summary":"","title":"Authors","type":"authors"},{"content":"","externalUrl":null,"permalink":"/series/","section":"Series","summary":"","title":"Series","type":"series"}]